# 编译器

### 语言的编译和解释

表面看： 编译是将源码编译成为一个最终的可执行文件，最终再执行；解释是边处理源文件边执行。

源代码====>（中间表示形式====>）基本操作序列====>生成最终动作

编译型和解释型语言的不同指出只是在于，这些过程发生的时机不一样。

编译型语言的代表是C，源代码被编译之后生成中间文件（.o和.obj），然后用连接器和汇编器生成机器码，也就是一系列基本操作的序列，机器码最后被执行生成最终动作。解释型的语言以Ruby为例，也经历了这些步骤，不同的是，C语言会把那些从源代码“变”来的基本操作序列（保存）起来，而Ruby直接将这些生成的基本操作序列（Ruby虚拟机）指令丢给Ruby虚拟机执行然后产生动作了。

Java需要预先把代码编译成虚拟机指令的，然后在运行这些虚拟机指令，有的教科书上会成为混合型或者半编译型。
像Python和lua这样就更不好分了，可以直接解释源代码运行，也可以编译为虚拟机指令然后再运行。
php编译之后的结果可以被Web Server缓存起来，甚至还可以先被翻译为C++，然后再编译。
.NET 的CLR运行时是Windows的组成部分，编译好的.NET 系列语言的代码直接生成可执行文件，然后被“直接”执行，看起来跟C没有什么太大的差别。
JavaScript可以被V8引擎编译为机器码然后执行，如果在node.js下，这个编译结果被缓存起来了，你说这跟编译好再执行的C有什么区别？


[link](https://www.zhihu.com/question/21486706/answer/18422107)


### 编译器
##### 依据试图生成的目标代码类型

纯机器代码

为特定机器生成代码，不依赖于操作系统和库程序，仅仅包含机器指令

拓广的机器代码

为操作系统和语言所拓广的机器体系结构生成代码。为执行这样的代码，需要操作系统和特定的语言支撑（虚拟机）。

虚拟机代码

生成的代码由虚指令组成，由良好的可移植性。

##### 依据生成目标代码的格式

汇编语言

可重定位的二进制代码格式

内存映像

前两种方法是生成可执行文件，第三种方法是直接生成到编译器的地址空间即内存中

### 编译器原理
词法分析
语法分析
中间代码生成：通常是四元表达式或者其他形式
优化： 代码位置调整，逻辑优化，数据存储在寄存器或者内存的选择（与之相关的各种场景也比较繁琐）
目标语言： 翻译为不同机器可以执行的特定语言，比如汇编等。定义目标语言的实现方式，比如是二元、三元；目标的数据和符号表的存储方式等

额外的两件事情伴随着每一个过程：
数据表格存放：符号表，常数表等等
错误处理：让错误提示尽可能的全面，范围可控，提示友好等。错误的产生有可能是由前面的延伸扩展等，定位准确等。

### 代码扫描
每个过程可以各自扫描一遍代码，也可以进行优化合并。比如通常的做法是词法分析，嵌入到语法分析的过程中等。

### 词法分析
词法缓冲区
向前看 ++ +
状态转换图： 为了写词法分析器更加容易，自动生成词法分析的理论基础。
表示标识符的状态转换图
表示数字的转换图

标识符的状态图区分定义符的过程有个查表的过程，也可以自定义一个$或者其他的符号来特指，减少搜索，提高效率。


### 语法分析



